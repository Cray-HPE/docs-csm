#
# MIT License
#
# (C) Copyright 2022 Hewlett Packard Enterprise Development LP
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.
#
{{define "worker.post-rebuild"}}
tasks:
  - name: update-bss-no-wipe
    templateRef:
      name: kubectl-and-curl-template
      template: shell-script
    arguments:
      parameters:
        - name: dryRun
          value: "{{ `{{inputs.parameters.dryRun}}` }}"
        - name: scriptContent
          value: |
            set -x
            set -o pipefail
            {{- include "common.helper-functions" . | indent 12 }}

            set_api_token
            set_target_xname

            TRIES=0
            ACTION="set metal.no-wipe=1 in BSS for $TARGET_XNAME"
            echo "Trying to: $ACTION"
            while ! /host_usr_bin/csi handoff bss-update-param --set metal.no-wipe=1 --limit $TARGET_XNAME ; do
              # sleep_or_exit is imported via common.retry
              sleep_or_exit
            done
            echo "Completed: $ACTION"
  - name: wait-for-cfs-after-rebuild
    templateRef:
      name: kubectl-and-curl-template
      template: shell-script
    arguments:
      parameters:
        - name: dryRun
          value: "{{ `{{inputs.parameters.dryRun}}` }}"
        - name: scriptContent
          value: |
            set -x
            set -o pipefail
            {{- include "common.helper-functions" . | indent 12 }}

            # These function are defined in the above include statement. 
            set_target_xname
            
            # set_cfs_status_file will retry the API request multiple times if needed.
            # The result will be stored in the $CFS_STATUS_FILE file
            set_cfs_status_file

            # Wait for component to become enabled (this should happen whether or not there is a desired configuration)
            ENABLED=$(cat "${CFS_STATUS_FILE}" | jq -r '.enabled')
            dtecho "ENABLED=$ENABLED"
            while [[ $ENABLED != true ]]; then
                if [[ $ENABLED != false ]]; then
                    dtecho "ERROR: Unexpected contents of 'enabled' field for CFS component '${TARGET_XNAME}': '${ENABLED}'"
                    exit 1
                fi

                echo "CFS component '${TARGET_XNAME}' still not enabled. Checking again after 30 seconds."
                sleep 30
                set_cfs_status_file
                ENABLED=$(cat "${CFS_STATUS_FILE}" | jq -r '.enabled')
                dtecho "ENABLED=$ENABLED"
            done
            echo "CFS component '${TARGET_XNAME}' is enabled"

            DESIRED_CONFIG=$(cat "${CFS_STATUS_FILE}" | jq -r '.desiredConfig')
            if [[ -z ${DESIRED_CONFIG} ]]; then
                dtecho "CFS component '${TARGET_XNAME}' has no desired configuration"
                exit 0
            fi
            dtecho "Desired configuration for CFS component '${TARGET_XNAME}' is '${DESIRED_CONFIG}'"

            CONFIG_STATUS=$(cat "${CFS_STATUS_FILE}" | jq -r '.configurationStatus')
            dtecho "CONFIG_STATUS=$CONFIG_STATUS"
            while [[ $CONFIG_STATUS == pending ]]; do
                dtecho "Waiting for CFS configuration to complete on ${TARGET_XNAME}"
                sleep 30
                set_cfs_status_file
                CONFIG_STATUS=$(cat "${CFS_STATUS_FILE}" | jq -r '.configurationStatus')
                dtecho "CFS configuration status of $(target_xname_and_name) is $CONFIG_STATUS"
            done

            if [[ $CONFIG_STATUS == failed ]]; then
                dtecho "$(target_xname_and_name) failed to successfully complete its CFS configuration"
                exit 1
            elif [[ $CONFIG_STATUS != configured ]]; then
                dtecho "$(target_xname_and_name) has unexpected CFS status: $CONFIG_STATUS"
                exit 1
            fi
  - name: ensure-csm-rpms-installed
    templateRef:
      name: ssh-template
      template: shell-script
    arguments:
      parameters:
        - name: dryRun
          value: "{{ `{{inputs.parameters.dryRun}}` }}"
        - name: scriptContent
          value: |
            ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null {{ `{{inputs.parameters.targetNcn}}` }} \
              'source /srv/cray/scripts/metal/metal-lib.sh;install_csm_rpms'
  - name: goss
    dependencies:
      - wait-for-cfs-after-rebuild
      - update-bss-no-wipe
      - ensure-csm-rpms-installed
    templateRef:
      name: ssh-template
      template: shell-script
    arguments:
      parameters:
        - name: dryRun
          value: "{{ `{{inputs.parameters.dryRun}}` }}"
        - name: scriptContent
          value: |
            ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null {{ `{{inputs.parameters.targetNcn}}` }} \
              -t "SW_ADMIN_PASSWORD='{{.SwitchPassword}}' \
                  GOSS_BASE=/opt/cray/tests/install/ncn \
                  goss -g /opt/cray/tests/install/ncn/suites/ncn-upgrade-tests-worker.yaml \
                    --vars=/opt/cray/tests/install/ncn/vars/variables-ncn.yaml validate \
                    --retry-timeout 1h"

{{end}}